# Registres et RAM

Salut, je suis Carrie Anne et bienvenue sur CrashCours d'informatique.Donc, dernier épisode, en utilisant uniquement des portes logiques, nousconstruit une ALU simple, qui effectue des opérations arithmétiqueset les opérations logiques, d'où le "A" etle "L".Mais bien sûr, il n'y a pas grand intérêt àcalculer un résultat pour le jeter- il serait utile de stocker cette valeur d'une manière ou d'une autre, et peut-être même d'exécuter plusieurs opérations à la suite.C'est là que la mémoire informatique entre en jeu !Si vous avez déjà été au milieu d'une longueCampagne RPG sur votre console, ou sloggingà travers un niveau difficile sur Démineur survotre bureau, et votre chien est passé, a trébuchéet débranchez le cordon d'alimentation du mur,vous connaissez l'agonie de perdre tous vos progrès.Condoléances.Mais la raison de votre perte est que votreconsole, votre ordinateur portable et vos ordinateurs fontl'utilisation de Random Access Memory, ou RAM, quistocke des choses comme l'état du jeu - tant quele courant reste allumé.Un autre type de mémoire, appelé persistantmémoire, peut survivre sans pouvoir, et c'estutilisé pour différentes choses; Nous parlerons dela persistance de la mémoire dans un épisode ultérieur.Aujourd'hui, nous allons commencer petit - littéralement en construisant un circuit qui peut en stocker un.simple .. peu d'informations.Après cela, nous passerons à l'échelle et construirons notremodule de mémoire très propre, et nous combineronsavec notre ALU la prochaine fois, quand nous aurons enfinconstruisons notre propre CPU !INTROTous les circuits logiques dont nous avons discutéjusqu'à présent aller dans une direction - toujours coulantvers l'avant - comme notre additionneur d'ondulation 8 bits dedernier épisode.Mais on peut aussi créer des circuits qui bouclentretour sur eux-mêmes.Essayons de prendre une porte OU ordinaire, etréinjecter la sortie dans l'une de ses entréeset voyez ce qui se passe.Tout d'abord, réglons les deux entrées sur 0.Donc 0 OU 0 est 0, et donc ce circuit toujourssorties 0.Si nous devions retourner l'entrée A à 1.1 OU 0 vaut 1, donc maintenant la sortie de la porte OUest 1.Une fraction de seconde plus tard, ça revient en boucleautour de l'entrée B, de sorte que la porte OU voit queses deux entrées sont maintenant à 1.1 OU 1 est toujours 1, donc il n'y a pas de changement danssortir.Si nous remettons l'entrée A à 0, la porte OUproduit toujours 1.Alors maintenant, nous avons un circuit qui enregistre un"1" pour nous.Sauf que nous avons un tout petit problème - celui-cile changement est permanent !Peu importe à quel point nous essayons, il n'y a aucun moyenpour que ce circuit revienne d'un 1à un 0.Regardons maintenant ce même circuit, maisavec une porte ET à la place.Nous allons démarrer les entrées A et B toutes les deux à 1.1 AND 1 sort 1 pour toujours.Mais, si nous retournons ensuite l'entrée A à 0, parce quec'est une porte ET, la sortie passera à 0.Donc ce circuit enregistre un 0, l'inversede notre autre circuit.Comme avant, peu importe l'entrée que nous appliquonsà l'entrée A par la suite, le circuit sortira toujours 0.Maintenant, nous avons des circuits qui peuvent enregistrer à la fois0 et 1.La clé pour en faire un morceau de mémoire utileest de combiner nos deux circuits dans ce qui estappelé le verrou ET-OU.Il a deux entrées, une entrée "set", qui définitla sortie à un 1, et une entrée "reset", quiremet la sortie à 0.Si set et reset sont tous les deux 0, le circuitsort ce qui a été mis en dernier.En d'autres termes, il se souvient d'un seul bitd'information!Mémoire!C'est ce qu'on appelle un « loquet » parce qu'il « verrouillesur » une valeur particulière et le reste.L'action de mettre des données en mémoire estappelée écriture, tandis que la sortie des donnéess'appelle lire.Ok, nous avons donc un moyen de stocker un seulpeu d'informations!Génial!Malheureusement, avoir deux fils différentspour l'entrée - définir et réinitialiser - est un peu déroutant.Pour rendre cela un peu plus facile à utiliser, nous avons vraimentvoulons un seul fil pour entrer des données, que nouspeut être réglé sur 0 ou 1 pour stocker la valeur.De plus, nous allons avoir besoin d'un filqui permet à la mémoire soit d'être disponiblepour écrire ou "verrouillé" --ce qui estappelée la ligne d'autorisation d'écriture.En ajoutant quelques portes logiques supplémentaires, nous pouvonsconstruire ce circuit, qui s'appelle un Gated Latchpuisque la "porte" peut être ouverte oufermé.Maintenant, ce circuit commence à devenir un peucompliqué.Nous ne voulons pas avoir à gérer tous lesportes logiques individuelles... donc comme avant, nous sommesva augmenter un niveau d'abstraction, etmettre tout notre circuit Gated Latch dans une boîte-- une boîte qui stocke un bit.Testons notre nouveau composant !Commençons tout à 0.Si nous basculons le fil de données de 0 à 1 ou1 à 0, rien ne se passe - la sortie reste à 0.C'est parce que le fil d'activation d'écriture estoff, ce qui empêche toute modification de la mémoire.Nous devons donc "ouvrir" la "porte" enen tournant le fil d'autorisation d'écriture sur 1.Maintenant, nous pouvons mettre un 1 sur la ligne de données pour enregistrerla valeur 1 à notre verrou.Remarquez comment la sortie est maintenant 1.Succès!Nous pouvons désactiver la ligne d'activation et la sortiereste comme 1.Encore une fois, nous pouvons basculer la valeur sur leligne de données tout ce que nous voulons, mais la sortie serarester le même.La valeur est enregistrée en mémoire.Maintenant, activons à nouveau la ligne d'activationutilisez notre ligne de données pour régler le verrou sur 0.Terminé.Activez la ligne désactivée et la sortie est 0.Et il fonctionne!Maintenant, bien sûr, la mémoire informatique qui nestocke un bit d'information n'est pas trèsutile - certainement pas suffisant pour exécuter Frogger.Ou n'importe quoi, vraiment.Mais nous ne sommes pas limités à utiliser un seulloquet.Si on met 8 loquets côte à côte, on peut ranger8 bits d'information comme un nombre de 8 bits.Un groupe de verrous fonctionnant comme ceci estappelé registre, qui contient un numéro unique,et le nombre de bits dans un registre est appelésa largeur.Les premiers ordinateurs avaient des registres 8 bits, puis16, 32, et aujourd'hui, de nombreux ordinateurs ont des registresqui ont une largeur de 64 bits.Pour écrire à notre registre, nous devons d'abordactiver tous les verrous.Nous pouvons le faire avec un seul fil qui se connecte à toutes leurs entrées d'activation, que nous avons définies sur 1.Nous envoyons ensuite nos données en utilisant les 8 donnéesfils, puis remettez enable à 0, etla valeur 8 bits est maintenant enregistrée en mémoire.Mettre les loquets côte à côte fonctionne bien pourun petit nombre de bits.Un registre 64 bits nécessiterait 64 fils en cours d'exécutionaux broches de données, et 64 fils allant àles sorties.Heureusement, nous n'avons besoin que d'un seul fil pour activer tousles verrous, mais c'est toujours 129 fils.Pour 256 bits, on se retrouve avec 513 fils !La solution est une matrice !Dans cette matrice, nous ne rangeons pas nos loquetsdans une rangée, nous les mettons dans une grille.Pour 256 bits, nous avons besoin d'une grille de verrous de 16 par 16avec 16 rangées et colonnes de fils.Pour activer un loquet, nous devons allumerle fil de ligne ET de colonne correspondant.Zoomons et voyons comment cela fonctionne.On ne veut que le loquet à l'intersectiondes deux fils actifs à activer,mais tous les autres verrous doivent rester désactivés.Pour cela, nous pouvons utiliser notre fidèle porte ET !La porte ET ne sortira un 1 que si la ligneet les fils de colonne sont tous les deux 1.Nous pouvons donc utiliser ce signal pour sélectionner de manière uniqueun seul loquet.Cette configuration rangée/colonne connecte tous nos loquetsavec un seul fil d'autorisation d'écriture partagé.Pour qu'un verrou soit activé en écriture,le fil de ligne, le fil de colonne et l'écritureactiver le fil doit tous être 1.Cela ne devrait jamais être vrai que pour un seulverrouiller à tout moment.Cela signifie que nous pouvons utiliser un seul fil partagépour les données.Parce qu'un seul loquet ne sera jamais écritactivé, un seul sauvegardera jamais les données-- le reste des verrous ignorera simplementvaleurs sur le fil de données car elles ne sont pasécriture activée.Nous pouvons utiliser la même astuce avec une activation de lecturefil pour lire les données plus tard, pour obtenir les donnéesd'un verrou spécifique.Cela signifie au total, pour 256 bits de mémoire,nous n'avons besoin que de 35 fils - 1 fil de données, 1 écritureactiver le fil, 1 lire le fil d'activation et 16 ligneset des colonnes pour la sélection.C'est une économie de fil importante !Mais nous avons besoin d'un moyen de spécifier de manière unique chaqueintersection.Nous pouvons penser à cela comme une ville, où vouspourrait vouloir rencontrer quelqu'un à la 12e avenueet 8th street -- c'est une adresse qui définitun carrefour.Le loquet dans lequel nous venons d'enregistrer notre un peu aune adresse de la ligne 12 et de la colonne 8.Puisqu'il y a un maximum de 16 lignes, nous stockons l'adresse de ligne dans un nombre de 4 bits.12 est 1100 en binaire.On peut faire de même pour l'adresse de la colonne : 8 vaut 1000 en binaire.Ainsi, l'adresse du verrou particulier que nousjuste utilisé peut être écrit comme 11001000.Convertir une adresse en quelque chosequi sélectionne la bonne ligne ou colonne, nous avons besoinun composant spécial appelé multiplexeur -- quiest le composant informatique avec un assez coolnom au moins par rapport à l'ALU.Les multiplexeurs existent dans toutes les tailles,mais parce que nous avons 16 lignes, nous avons besoin d'un 1 à16 multiplexeur.Cela fonctionne comme ça.Vous lui donnez un nombre de 4 bits, et il se connectela ligne d'entrée à une ligne de sortie correspondante.Donc si on passe en 0000, il sélectionnera letoute première colonne pour nous.Si on passe en 0001, la colonne suivante est sélectionnée,etc.Nous avons besoin d'un multiplexeur pour gérer nos ligneset un autre multiplexeur pour gérer les colonnes.Bon, ça recommence à se compliquer,alors faisons de notre mémoire 256 bits son propre composant.Encore une fois un nouveau niveau d'abstraction !Il prend une adresse 8 bits pour l'entrée - le4 bits pour la colonne et 4 pour la ligne.Nous avons également besoin de fils d'activation d'écriture et de lecture.Et enfin, nous n'avons besoin que d'un seul câble de données, quipeut être utilisé pour lire ou écrire des données.Malheureusement, même 256 bits de mémoire ne sont pasassez pour exécuter beaucoup de n'importe quoi, nous avons donc besoinpour encore plus grandir !Nous allons les aligner.Tout comme avec les registres.Nous allons faire une rangée de 8 d'entre eux, afin que nous puissionsstocker un nombre de 8 bits - également appelé octet.Pour ce faire, nous alimentons exactement la même adressedans chacun de nos 8 composants de mémoire 256 bitsen même temps, et chacun économise un bitdu nombre.Cela signifie que le composant que nous venons de créer peutstocker 256 octets à 256 adresses différentes.Encore une fois, pour garder les choses simples, nous voulons partirderrière cette complexité intérieure.Au lieu de considérer cela comme une série demodules et circuits de mémoire individuels, nous allonsconsidérez-le comme une banque uniforme de données adressablesMémoire.Nous avons 256 adresses, et à chaque adresse,nous pouvons lire ou écrire une valeur de 8 bits.Nous allons utiliser ce composant mémoireprochain épisode lorsque nous construisons notre CPU.La façon dont les ordinateurs modernes évoluent en mégaoctetset gigaoctets de mémoire est en faisant la même chosechose que nous avons faite ici -- garder l'emballagede petits paquets de mémoire en plus gros, etarrangements de plus en plus grands.Au fur et à mesure que le nombre d'emplacements de mémoire augmente, notreles adresses doivent aussi grandir.8 bits contiennent suffisamment de nombres pour fournir des adresses pour 256 octets de notre mémoire, mais c'est tout.Pour adresser un gigaoctet – ou un milliard d'octetsde mémoire - nous avons besoin d'adresses 32 bits.Une propriété importante de cette mémoire est quenous pouvons accéder à n'importe quel emplacement de mémoire, à n'importe quelmoment, et dans un ordre aléatoire.Pour cette raison, il s'appelle Random-AccessMémoire ou RAM.Lorsque vous entendez des gens parler de la quantité de RAM d'un ordinateur, c'est la mémoire de l'ordinateur.La RAM est comme le court terme ou le travail d'un humainmémoire, où vous gardez une trace des choses qui se passenten ce moment - comme si vous aviez ou nondéjeuner ou payé votre facture de téléphone.Voici un véritable bâton de RAM - avec 8 mémoiresmodules soudés sur la carte.Si nous ouvrions prudemment l'un de ces moduleset zoomé, la première chose que vous verriezsont 32 carrés de mémoire.Zoomez sur l'un de ces carrés, et nous pourronsvoir chacun est composé de 4 blocs plus petits.Si on zoome à nouveau, on descend jusqu'à la matricede bits individuels.Il s'agit d'une matrice de 128 par 64 bits.Cela fait 8192 bits au total.Chacun de nos 32 carrés a 4 matrices, doncc'est 32 mille 7 cents 68 bits.Et il y a 32 cases au total.Donc, au total, c'est environ 1 millionbits de mémoire dans chaque puce.Notre clé RAM a 8 de ces puces, donc dansau total, cette RAM peut stocker 8 millions de bits,autrement connu sous le nom de 1 mégaoctet.Ce n'est pas beaucoup de mémoire ces jours-ci - ceest un module RAM des années 1980.Aujourd'hui, vous pouvez acheter de la RAM d'un gigaoctetou plus de mémoire - c'est des milliards d'octetsde mémoire.Donc, aujourd'hui, nous avons construit un morceau de SRAM - StaticRandom-Access Memory - qui utilise des verrous.Il existe d'autres types de RAM, comme la DRAM, la mémoire Flash et la NVRAM.Ceux-ci sont très similaires en fonction de SRAM,mais utilisez des circuits différents pour stocker l'individubits - par exemple, en utilisant une logique différentegrilles, condensateurs, pièges à charge ou memristors.Mais fondamentalement, toutes ces technologiesstocker des bits d'information massivement imbriquésmatrices de cellules mémoire.Comme beaucoup de choses en informatique, le principe fondamentalle fonctionnement est relativement simple.. c'est ledes couches et des couches d'abstractionépoustouflant - comme une poupée russe quidevient de plus en plus petit et de plus en plus petit.Je vous verrai la semaine prochaine.
